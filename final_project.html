<meta charset="utf-8">

<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>MSAN 622 Information Visualization</title>

<link href="css/bootstrap.min.css" rel="stylesheet">
<!-- <link href="css/bootstrap-theme.min.css" rel="stylesheet"> -->

<style type="text/css">
    body {
        padding-top: 20px;
        padding-bottom: 20px;
    }
</style>

<!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>

<body>

<!-- Fixed Navbar -->
<nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle Navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="#">MSN 622</a>
        </div>

        <div id="navbar" class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li><a href="/information_visualization/#homework">Homework</a></li>
                <li><a href="/information_visualization/#project">Project</a></li>
                <li><a href="/information_visualization/#participation">Participation</a></li>
            </ul>

            <ul class="nav navbar-nav navbar-right">
                <li><a href="/information_visualization/#about">About</a></li>
                <li><a href="/information_visualization/#contact">Contact</a></li>
            </ul>
        </div><!--/.nav-collapse -->
    </div>
</nav>

<div class="jumbotron">
    <div class="container">
        <h2>Wine Quality</h2>
        <h3>Final Project</h3>
        <h4>Alice Priyanka Benziger</h4>

       
    </div>
</div>

<html lang="en">

<head>
    <meta charset="utf-8">
    <!-- <title>Learning SVG</title> -->

    <!-- load D3 and TopoJSON //-->
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>


</head>

<body>
<!-- placeholder SVGs //-->

<div class="container">
<h3>Intoduction</h3>
<p>The following set of visualizations are aimed at uncovering the physiochemical properties that make a wine superior in quality. I chose a data set containing quality related factors pertaining to red and white variants of the Portuguese "Vinho Verde" wine. The dataset is from UCI's machine learning <h10><a href="http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/">repository.</a></h10> For this study I am including only the red variant. We have 11 factors in hand namely, fixed acitidity, volatile acidity, citric acid content, residual sugar, chlorides, free sulphur dioxide, total sulphur dioxide, density, pH, sulphate content and alcohol. Also, a final variable called quality that gives a quality score (ranging from 0-10) for different combinations of the 11 variables mentioned. More details on the dataset can be found <h10><a href="http://alicebenzi.github.io/information_visualization/project_dataset.html">here</a></h10>. To vizualize the dataset, I used scatterplot matrix, parallel coordinate plots and small multiple plots. These techniques and their inferences are detailed below.</p>

  <!-- <p style ="font-size:18px"> Basic functionality </p>
  <p style ="font-size:15px"> Line and Area plots </p> -->


<h3>Visualizations</h3>
 


 
</div>
<br> </br>

<!-- <div id="final"> -->
<div class="container">
<h3 style="margin-left:210px;">Scatterplot matrix</h3>
</div>

<svg id="plot1"></svg>
<div class="container">
<br> </br>
<br> </br>
<br> </br>
<h3 style="margin-left:330px;">Parallel cordinate plot</h3>
</div>


<div id="plot3"></div>
<div class="container">
<br> </br>
<br> </br>
<br> </br>


<h3 style="margin-left:330px;">Small multiple plots</h3>
</div>
<div id="plot2"></div>

<!-- <svg id="plot3" class="small" width="200" height="200"></svg> -->
</div>
<style>



/*body {
    background-color: white;
    font: 12px
    sans-serif;
    margin: 8px;
}*/

div#block {
    max-width: 950px;
}
/*
svg {
    background-color: white;
    margin: 1px;
    float: left;
}*/



.outline {
    stroke: black;
    stroke-width: 1px;
}
svg#plot1 svg {
  font: 6px sans-serif;
  padding: 10px;
}
svg#plot1 .axis text {
  text-shadow: 0 0.5px 0 #fff;
  cursor: move;
}


svg#plot1 .axis,
svg#plot1 .frame {
  shape-rendering: crispEdges;
}

/*svg#plot1 .legend circle {
                  fill-opacity: 1;
                }
svg#plot1 .legend text {
font-size: 12px;
font-style: oblique;
}*/

svg#plot1 .axis line {
  stroke: none;
}

svg#plot1 .axis line:hover {
  stroke: #aaa;
}

svg#plot1 .axis path {
  display: none;
}

svg#plot1 .frame {
  fill: none;
  stroke: #aaa;
}

svg#plot1 circle {
  fill-opacity: 1;
}

svg#plot1 circle.hidden {
  fill: #ccc !important;
}

svg#plot1 .extent {
  fill: #000;
  fill-opacity: .125;
  stroke: #fff;
}

#plot1 .legend circle {
                  fill-opacity: 1;
                }
#plot1 .legend text {
font-size: 12px;
font-style: oblique;
}

svg {
  font: 10.5px sans-serif;
}
svg#plot3 .background path {
  fill: none;
  stroke: #ccc;
  stroke-opacity: .4;
  shape-rendering: crispEdges;
}
svg#plot3 .foreground path {
  fill: none;
  /*stroke: steelblue;*/
  stroke-opacity: 0.5;
}
svg#plot3 .brush .extent {
  fill-opacity: .3;
  stroke: #fff;
  shape-rendering: crispEdges;
}
svg#plot3 .axis line,
svg#plot3 .axis path {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
svg#plot3 .axis text {
  text-shadow: 0 1px 0 #fff;
  cursor: move;
}

 svg#plot2 body {
    font: 11px sans-serif;
    margin: 10px;
  }

  svg#plot2 .axis path,
  svg#plot2 .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
  }

  svg#plot2 .bar:hover {
    fill: #bcbcbc ;
  }

    .x.axis path {
      display: none;
    }

  .d3-tip {
    line-height: 1;
    font-weight: bold;
    padding: 12px;
    background: rgba(0, 0, 0, 0.8);
    color: #efefef;
    border-radius: 2px;
  }

  /* Creates a small triangle extender for the tooltip */
  .d3-tip:after {
    box-sizing: border-box;
    display: inline;
    font-size: 10px;
    width: 100%;
    line-height: 1;
    color: rgba(0, 0, 0, 0.8);
    content: "\25BC";
    position: absolute;
    text-align: center;
  }

  /* Style northward tooltips differently */
  .d3-tip.n:after {
    margin: -1px 0 0 0;
    top: 100%;
    left: 0;
  }





</style>


<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.min.js"></script>

<script>
function plot1(){

  var //width = 960,
    size = 150,
    padding = 25.5;

    var x = d3.scale.linear()
        .range([padding / 2, size - padding / 2]);
        x.nice();

    var y = d3.scale.linear()
        .range([size - padding / 2, padding / 2]);
        y.nice();

    var xAxis = d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(5);

    var yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(5);

    
    var color = d3.scale.ordinal().range(["#fa9fb5","#df65b0","#8856a7"]);

    d3.csv("red_wine_new.csv", function(error, data) {
    var domainByTrait = {},
      traits = d3.keys(data[0]).filter(function(d) { return d !== "quality" && d !== 'alcohol' && d !== 'fixed.acidity' && d !== 'free.sulfur.dioxide' && d !== 'density'    && d !== 'total.sulfur.dioxide' && d !== 'residual.sugar'; });
      n = traits.length;

  traits.forEach(function(trait) {
    domainByTrait[trait] = d3.extent(data, function(d) { return d[trait]; });
  });

    xAxis.tickSize(size * n)
    //.tickFormat(d3.format("0.02f"));
    yAxis.tickSize(-size * n)
    //.tickFormat(d3.format(",."));

    var brush = d3.svg.brush()
          .x(x)
          .y(y)
          .on("brushstart", brushstart)
          .on("brush", brushmove)
          .on("brushend", brushend);

    var svg = d3.select("#plot1")
          .attr("width", size * n + 8*padding)
          .attr("height", size * n + padding)
        .append("g")
          .attr("transform", "translate(" + padding + "," + padding / 2 + ")");



   

    var legend = svg.selectAll(".legend")
                          //.data(color.domain().slice().reverse())
                          .data(["Low", "Medium", "High"])
                          .enter().append("g")
                          .attr("class", "legend")
                          .attr("transform", function(d, i) { return "translate(800," +   (i *20 +300) + ")"; })

                     /*legend.append("svg:circle")
                            .attr("r", 6)*/
                    legend.append("rect")
                          .attr("class", String)
                          .attr("x2", 20)
                          .attr("width",18)
                          .attr("height",18)
                          .style("fill", color);//function(d) {return color(d.quality);});
                     legend.append("text")
                          .attr("x", 20)
                          .attr("dy", "1em")
                          //.text(["High", "Medium", "Low"])
                          .text(function(d) {return d;});

      svg.selectAll(".x.axis")
          .data(traits)
        .enter().append("g")
          .attr("class", "x axis")
          .attr("transform", function(d, i) { return "translate(" + (n - i - 1) * size + ",0)"; })
          .each(function(d) { x.domain(domainByTrait[d]); d3.select(this).call(xAxis); });

      svg.selectAll(".y.axis")
          .data(traits)
        .enter().append("g")
          .attr("class", "y axis")
          .attr("transform", function(d, i) { return "translate(0," + i * size + ")"; })
          .each(function(d) { y.domain(domainByTrait[d]); d3.select(this).call(yAxis); });

      var cell = svg.selectAll(".cell")
          .data(cross(traits, traits))
        .enter().append("g")
          .attr("class", "cell")
          .attr("transform", function(d) { return "translate(" + (n - d.i - 1) * size + "," + d.j * size + ")"; })
          .each(plot);

      // Titles for the diagonal.
      cell.filter(function(d) { return d.i === d.j; }).append("text")
          .attr("x", padding)
          .attr("y", padding)
          .attr("dy", ".71em")
          .text(function(d) {
            switch (d.x) {
                case "citric_acid": return "Citric acid"; 
                case "residual_sugar": return "Residual sugar"; 
                case "pH": return "pH"; 
                case "total.sulfur.dioxide" : return "Total SO2";
                case "free.sulfur.dioxide" : return "Free SO2";
                case "fixed.acidity" : return "Fixed Acidity";
                case "volatile.acidity" : return "Volatile Acidity";
                case "citric.acid" : return "Citric Acid";
                case "residual.sugar" : return "Residual Sugar";
                case "density" : return "Density";
                case "alcohol" : return "Alcohol";
                case "sulphates" : return "Sulphates";
                case "quality" : return "Quality";
                case "chlorides" : return "Chlorides";
            }
            return d.x;
        })
      .on('mouseover', function (d) {
                                tip2.show(d);
                                fade(d.quality, .2);
                            })
                            .on('mouseout', function (d) {
                                tip2.hide(d);
                                fadeOut(d);
                            });;

      cell.call(brush);

      function plot(p) {
        var cell = d3.select(this);

        x.domain(domainByTrait[p.x]);
        y.domain(domainByTrait[p.y]);

        cell.append("rect")
            .attr("class", "frame")
            .attr("x", padding / 2-3.5)
            .attr("y", padding / 2-3.5)
            .attr("width", size - padding+15)
            .attr("height", size - padding+10);

        cell.selectAll("circle")
            .data(data)
          .enter().append("circle")
            .attr("cx", function(d) { return x(d[p.x]); })
            .attr("cy", function(d) { return y(d[p.y]); })
            .attr("r", 2)
            .style("fill", function(d) { return color(d.quality); });
      }

      var brushCell;

      // Clear the previously-active brush, if any.
      function brushstart(p) {
        if (brushCell !== this) {
          d3.select(brushCell).call(brush.clear());
          x.domain(domainByTrait[p.x]);
          y.domain(domainByTrait[p.y]);
          brushCell = this;
        }
      }

      // Highlight the selected circles.
      function brushmove(p) {
        var e = brush.extent();
        svg.selectAll("circle").classed("hidden", function(d) {
          return e[0][0] > d[p.x] || d[p.x] > e[1][0]
              || e[0][1] > d[p.y] || d[p.y] > e[1][1];
        });
      }

      // If the brush is empty, select all circles.
      function brushend() {
        if (brush.empty()) svg.selectAll(".hidden").classed("hidden", false);
      }

      function cross(a, b) {
        var c = [], n = a.length, m = b.length, i, j;
        for (i = -1; ++i < n;) for (j = -1; ++j < m;) c.push({x: a[i], i: i, y: b[j], j: j});
        return c;
      }

      d3.select(self.frameElement).style("height", size * n + padding + 20 + "px"); });

      function fade(Quality, opacity) {

        svg.selectAll("rect")
            .transition().duration(100)
            .style("fill", function(d) {return color(d.quality); })
            .filter(function (d) { return d.quality != Quality; })
            .style("opacity", opacity);
    }

    function fadeOut() {
        svg.selectAll("rect")
            .transition().duration(100)
            .style("fill", function(d) {return color(d.quality); })
            .style("opacity", function (d) { opacity(d.quality); });
    }

}
plot1();

function plot3() {
    // http://bl.ocks.org/mbostock/7586334
    // http://bl.ocks.org/chrisbrich/4173826
    // https://dexvis.wordpress.com/2013/01/28/d3js-parallel-lines-and-football/
    // update dimensions

  

    
    var margin = {top: 50, right: 10, bottom: 10, left: 10},
        width = 1060 - margin.left - margin.right,
        height = 600 - margin.top - margin.bottom;
  
    var x = d3.scale.ordinal().rangePoints([0, width], 1),
        y = {},
        dragging = {};
    
    var line = d3.svg.line(),
        axis = d3.svg.axis().orient("right");
        //background,
        //foreground;

    var color = d3.scale.ordinal().range(["#fa9fb5","#df65b0","#8856a7"]);
    var svg = d3.select("#plot3").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .attr("id", "plot3")
        .attr("display", "block")
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    categoricals = [];
    
    d3.csv("red_wine_new.csv", function(error, data) {
    
      x.domain(dimensions = d3.keys(data[0]).filter(function(d) {
          if (d === "none") return false;
          if (d === "quality") {
            // console.log("I found a categorical");
              categoricals.push(d);
              y[d] = d3.scale.ordinal()
              .domain(data.map(function(p) { return p[d]; }))
              .rangePoints([height, 0]);
          } else {
              y[d] = d3.scale.linear()
              .domain(d3.extent(data, function(p) { return +p[d]; })).nice()
              .range([height, 0]);
          }
          return true;
    }));
  

    // Add grey background lines for context
    background = svg.append("g")
        .attr("class", "background")
        .selectAll("path")
        .data(data)
        .enter().append("path")
        .attr("d", path);
      
      // Add colored foreground lines for focus
      foreground = svg.append("g")
          .attr("class", "foreground")
          .selectAll("path")
          .data(data)
          .enter().append("path")
          .style("stroke", function (d) { return color(d.quality); })
          .style("stroke-width", 1.5)
          .attr("d", path);
    // // Add a group element for each dimension
    var g = svg.selectAll(".dimension")
        .data(dimensions)
      .enter().append("g")
        .attr("class", "dimension")
        .attr("transform", function(d) { return "translate(" + x(d) + ")"; })
        .call(d3.behavior.drag()
          .on("dragstart", function(d) {
            dragging[d] = this.__origin__ = x(d);
            background.attr("visibility", "hidden");
          })
          .on("drag", function(d) {
            dragging[d] = Math.min(width, Math.max(0, this.__origin__ += d3.event.dx));
            foreground.attr("d", path);
            dimensions.sort(function(a, b) { return position(a) - position(b); });
            x.domain(dimensions);
            g.attr("transform", function(d) { return "translate(" + position(d) + ")"; })
          })
          .on("dragend", function(d) {
            delete this.__origin__;
            delete dragging[d];
            transition(d3.select(this)).attr("transform", "translate(" + x(d) + ")");
            transition(foreground)
                .attr("d", path);
            background
                .attr("d", path)
                .transition()
                .delay(500)
                .duration(0)
                .attr("visibility", null);
          }));
    // Add an axis and title.
    g.append("g")
        .attr("class", "axis")
        .each(function(d) { d3.select(this).call(axis.scale(y[d])); })
      .append("text")
        .attr("text-anchor", "middle")
        .attr("y", -9)
        .text(
          function(d) {
            switch (d) {
                case "citric_acid": return "Citric acid"; 
                case "residual_sugar": return "Residual sugar"; 
                case "pH": return "pH"; 
                case "total.sulfur.dioxide" : return "Total SO2";
                case "free.sulfur.dioxide" : return "Free SO2";
                case "fixed.acidity" : return "Fixed Acidity";
                case "volatile.acidity" : return "Volatile Acidity";
                case "citric.acid" : return "Citric Acid";
                case "residual.sugar" : return "Residual Sugar";
                case "density" : return "Density";
                case "alcohol" : return "Alcohol";
                case "sulphates" : return "Sulphates";
                case "quality" : return "Quality";
                case "chlorides" : return "Chlorides";

            }
            return d;
        });
    // Add and store a brush for each axis
    g.append("g")
        .attr("class", "brush")
        .each(function(d) { d3.select(this).call(y[d].brush = d3.svg.brush().y(y[d]).on("brushstart", brushstart).on("brush", brush)); })
      .selectAll("rect")
        .attr("x", -8)
        .attr("width", 16);

    });
    function position(d) {
      var v = dragging[d];
      return v == null ? x(d) : v;
    }
    function transition(g) {
      return g.transition().duration(500);
    }
    // Returns the path for a given data point.
    function path(d) {
      return line(dimensions.map(function(p) { return [position(p), y[p](d[p])]; }));
    }
    // When brushing, donâ€™t trigger axis dragging.
    function brushstart() {
      d3.event.sourceEvent.stopPropagation();
    }
    // Handles a brush event, toggling the display of foreground lines.
    function brush() {
      var actives = dimensions.filter(function(p) { return !y[p].brush.empty(); }),
          extents = actives.map(function(p) { return y[p].brush.extent(); });
      foreground.style("display", function(d) {
          return actives.every(function(p, i)
          {
              // Categorical
              if (["quality"].indexOf(p) > -1) {
                  return extents[i][0] <= y[p](d[p]) && y[p](d[p]) <= extents[i][1];
              } else {
                  // Numeric
                  return extents[i][0] <= d[p] && d[p] <= extents[i][1];
              }
          }) ? null : "none";
      });
    }
}

plot3();

function plot2(){

  var margin = {top: 45, right: 100, bottom: 20, left: 20},
      width = 380 - margin.left - margin.right,
      height = 200 - margin.top - margin.bottom;

  var formatPercent = d3.format(",.0f");

  var color = d3.scale.ordinal().range(["#fa9fb5","#df65b0","#8856a7"]);


  var x = d3.scale.ordinal()
      .rangeRoundBands([0, width+10], .1);

  // Scales. Note the inverted domain fo y-scale: bigger is up!
  var y = d3.scale.linear()
      .range([height, 0]);

  var xAxis = d3.svg.axis()
      .scale(x)
      .orient("bottom");

  var yAxis = d3.svg.axis()
      .scale(y)
      .orient("left");
      //.tickFormat(formatPercent);

  var tip = d3.tip()
    .attr('class', 'd3-tip')
    .offset([-10, 0])
    .html(function(d) {
      return "<strong>" +d.quality +":"+ "\t" + d.content + "</strong><br/><span style='color:#fff'>" + d.value + "%</span>";
    })

  // csv loaded asynchronously
  d3.csv("small_multiples_.csv", type, function(data) {

    // Data is nested by chemical content
    var content = d3.nest()
        .key(function(d) { return d.content; })
        .entries(data);
    var opacity = d3.scale.linear()
            .domain([d3.min(data, function (d) { return d[name]; }), 
                     d3.max(data, function (d) { return d[name]; })])
            .range([1, .5]);

    
    x.domain(data.map(function(d) { return d.quality; }));
    y.domain([0, d3.max(content, function(s) { return s.values[0].value; })]);

    // Add an SVG element for each country, with the desired dimensions and margin.
    var svg = d3.select("#plot2").selectAll("svg")
      .data(content)
      .enter()
      .append("svg:svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    svg.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    svg.append("g")
        // Hide y axis
        // .attr("class", "y axis")
        // .call(yAxis)
      .append("text")
      .attr("x", width + 10)
      .attr("y", height/1.2)
      .attr("dy", ".71em")
      .attr("text-anchor", "start")
      .attr("font-size", "1.1em")
      .text(function(d) { switch (d.key) {
                  //case "citric_acid": return "Citric acid"; 
                  //case "residual_sugar": return "Residual sugar"; 
                  case "pH": return "pH"; 
                  case "total.sulfur.dioxide" : return "Total SO2";
                  case "free.sulfur.dioxide" : return "Free SO2";
                  case "fixed.acidity" : return "Fixed Acidity";
                  case "volatile.acidity" : return "Volatile Acidity";
                  case "citric.acid" : return "Citric Acid";
                  case "residual.sugar" : return "Residual Sugar";
                  case "density" : return "Density";
                  case "alcohol" : return "Alcohol";
                  case "sulphates" : return "Sulphates";
                  case "quality" : return "Quality";
                  case "chlorides" : return "Chlorides";
              }
              return d.key;});

    // Accessing nested data: https://groups.google.com/forum/#!topic/d3-js/kummm9mS4EA
    // data(function(d) {return d.values;}) 
    // this will dereference the values for nested data for each group
    svg.selectAll(".bar")
        .data(function(d) {return d.values;})
        .enter()
        .append("rect")
        .attr("class", "bar")
        .attr("x", function(d) { return x(d.quality); })
        .attr("width", x.rangeBand())
        .attr("y", function(d) { return y(d.value); })
        .attr("height", function(d) { return height - y(d.value); })
        .attr("fill", function(d) {return color(d.quality)})
        .attr("opacity",0.85)
        .on('mouseover',  function (d) {
                    tip.show(d);
                    fade(d.quality, 0.00001);
                })
        .on('mouseout',  function (d) {
                    tip.hide(d);
                    fadeOut(d);
                });
    function fade(Quality, opacity) {

          svg.selectAll("rect")
              .transition().duration(800)
              .style("fill", function(d) {return color(d.quality); })
              .filter(function (d) { return d.quality != Quality; })
              .style("opacity", opacity);
      }

      function fadeOut() {
          svg.selectAll("rect")
              .transition().duration(800)
              .style("fill", function(d) {return color(d.quality); })
              .style("opacity", function (d) { opacity(d.quality); });
      }
      

    svg.call(tip);

  });

  function type(d) {
    d.value = +d.value;
    return d;
  }
}
plot2();
</script>




<div class="container">
<br> </br>
<br> </br>
<h3>Techniques</h3>
<h4>Scatterplot matrix</h4>
<p>
   I began visualizing the dataset by obtaining a scatter plot matrix of quality score plus all the 11 variables to see interactions between variables. A scatter plot matrix was chosen to get a sense of the variables that deem important to the different quality levels and also to check if interactions between the variables would uncover patterns. A scatterplot matrix with all 11 variables colored by each of the different quality scores (0-10) made the visualization very cluttered. Also it was difficult to infer a pattern from the visualization. So the first step was to aggregate/condense the dataset to make the visualizations cleaner and meaningful. The red wine variant has 1599 rows with quality scores varying from 3 - 8. A majority of the data points were concentrated around scores 5 & 6. Since the data is highly unbalanced, the quality is further grouped as Low (scores <= 4), Medium (scores 5 & 6) and High (scores >=7). After grouping, there are 217 data points for "High", 63 for "Low" and 1319 for "Medium". The imbalance in dataset is resolved by bootstrapping the data set to have equal number of data points for each of the categories. To avoid having a high data density visualisation, the number of samples from each of the categories were reduced to 200 data points each. The final dataset used can be found <h10><a href="https://github.com/alicebenzi/information_visualization/blob/gh-pages/red_wine_new.csv">here.</a></h10> The scatterplot matrix now started looking more meaningful. However, not all 11 variables were useful in deciphering insights. Hence only 5 variables namely, Volatile Acidity, Citric Acid, Chlorides, pH and Sulphate levels are included in the final visualization. Some interesting patterns are obtained from this visualization which will be discussed later in the conclusions. </p>

   <p>

   The data-ink ratio of this visualization is pretty low. I have excluded gridlines from the scatterplot matrix as, the matrix mainly intended to uncover patterns and relationships between variables in the dataset. Furthermore exact values can be read from some of the following visualizations, like the parallel coordinate plot. I tried to minimize the data density as much as I can, without losing useful information from the dataset. I have included only 200 data points from each of the three quality categories created. Adding additional data points didn't seem to explain any new information. Reducing some datapoints made it slightly difficult to visualize obvious patterns. However since it is a scatterplot matrix, I could have maintained only the upper or lower half of the matrix as they are exhibiting the same information. And there is no lie-factor in this visualization.

   <p> This visualization has been influenced by the scatterplot matrix created by <h10><a href="http://bl.ocks.org/mbostock/4063663">mbostock.</a><h10>
</p>
<p>

  </p>
  <p>
<h4>Parallel coordinates</h4>

<p>
  In the scatterplot matrix, I included only a few variables that either showed some iteraction with other variables or the variables that together helped see distinct patterns emerging. A parallel coordinate plot is included to see how the quality score varied among all the different variables. The plot gives a sense of how the different variables vary as the quality increases from low to medium to high. Also parallel coordinates are the best way to visualize a n-dimensional dataset with ease. The same grouping scheme and dataset used for the scatterplot matrix has been used here. </p>

  <p> The data here are colored according to the different quality scores. The data density is slightly on the higher side. However, I have excluded as many irrelevant data points as I could without losing relevant information. The data ink-ratio is low. All coordinates are labelled. I have excluded legend information to improve data-ink ratio since there is a labelled coordinate corresponding to quality levels. More details about the inferences from this visualization is described in the conclusion. 
  
</p>

<p> This visualization is influenced by a parallel coordinate plot as shown <h10><a href="http://bl.ocks.org/jasondavies/1341281">here.</a><h10>
</p>

<h4>Small multiple plots</h4>

<p>
  Both the scatterplot matrix and the parallel coordinate plots exhibit the dataset in different forms. The visualizations above give a good idea of the quality score varies across variables and across interactions between variables. The parallel coordinate plot shows that quality levels vary widely across certain variables compared to the others. Small multiple plots are included to get an idea of the quantity by which the different physiochemical contents vary across different quality levels. I implemented small multiple bar charts for each of the different variables. For example from the parallel coordinate plot and scatterplot matrix volatile acidity was considered an important variable capable of creating a clear distinction between the different quality levels. The small multiple bar chart will quantify this distinction by making it clear the exact levels of the contents of the different variables across the three quality levels.

  <p> To obtain the small multiple plot data had to be first brought to a single scale so that it becomes easier to look across different variables and improved aesthetics. After scaling the data set, aggregation is performed at a variable level (ex alcohol, density etc) and within each variable, the data were further aggregated into subgroups of low, medium and high. After this grouping, within subgroup means were calculated. The final data set  have 3 columns namely content, quality and value and three rows for each of the contents. The final dataset used can be found <h10><a href="https://github.com/alicebenzi/information_visualization/blob/gh-pages/small_multiples_.csv">here.</a></h10></p>

  <p> The data density for this visualization is very low. The data-ink ratio is relatively low. The bars do no exhibit any values. The values are included in a tooltip feature which can be seen by hovering over the bars. This is to improve the data-ink ratio. Since all the x-axis represents the same information, I could have included it only for plots in the last row. But doing this made the plots slightly confusing as the x-axis can be read only from the last plot. The lie factor is very low. I have brought all the datapoints to a single scale between 0 and 1 to avoid any lie-factor issues.
 </p>

<p>Some parts of the visualization is based on small multiple bar charts found <h10><a href="http://bl.ocks.org/officeofjane/7315455">here.</a></h10>
</p>

</div> 

<div class="container">
<h3>Interactivity</h3>

<h4> Scatterplot matrix </h4>
<p> For the scatterplot matrix I implemented a brushing feature. The brushing feature helps select and highlight a specific cluster of points. For example, if I choose points corresponding to high quality wine from one of the grids, the same points will be highlighted across all grids. Brushing can be performed by selecting a particular set of points using the mouse/mousepad. A panning is also implemented along with brushing. If we select a partcular set of points and move the selected area with the help of a mousepad, you can brush along a grid, say from top left corner to bottom right corner of a grid. This helps to see how the color of the points change as we pan along, thus giving an idea of how the quality levels vary across the different variables. </p>

<h4> Parallel coordinate plot </h4>
<p> Brushing, panning and reorderable axis features are added to the parallel coordinate plot. Brushing allows the user to filter data and look for patterns along the axis. A subsequent panning of the filtered windows allows users to see how each of the variables vary with the selected column. The order of the axis can be changed. For example, I have included quality levels as the final coordinate. However, one can pull it all the way to the beginning of the plot. Also reordering axis may help to tease out patterns that are not very obvious with a particular ordering of axes.</p>

<h4> Small multiple plots</h4>
<p> A highlighting/filtering feature along with tooltips are added to the small multiple plot. Hovering over a bar of a particular quality level will highlight all the corresponding bars for all the multiples. The remaining two bars will fade at this point. Also a tooltip with the average percentage content of the variable in question will pop up upon hovering.</p>


</div>

<div class="container">
<h3>Feedback</h3>

<p>For the prototype, I had implemented the scatterplot matrix. I initially had colored the different quality levels with distinct red, green and orange colors. Though these colors helped in dsitinguishing between the three quality levels, changing the color scale to something more meaningful was a suggestion and I have implemented it. My initial scatterplot matrix had points overlapping with the grid boundaries. There was a suggestion to avoid spilling of points across the grids. I made sure that now all the points are within each of the grids. Removed gridlines as per suggestion to improve data ink ratio. Another suggestion was to include only an upper or lower triangular matrix as data above and below the diagonal represents the same information. I tried implementing this but ran into multiple aesthetic issues and finally dropped it.
  </p>

</div>
<div class="container">
<h3>Challenges</h3>
I initially tried to plot separate gridlines within each of the scatterplot grids rather than extending ticks to act as gridlines. This was time consuming and the datapoints started flowing outside the small matrices. As per a feedback that I received on the scatterplot matrix, I tried making the scatterplot matrix a lower triangular matrix. I had no success with this after trying for hours. It was challenging to get the data in the right format for small multiple plots. Once I obtained the plots, figuring out on how to apply interaction across all the multiples were challenging. I tried applying the same principle to link interactions across all three plots but I had trouble implementing it. And since the plots do not belong to a dashboard, it wasn't very relevant. 
</div>

<div class="container">
<h3>Conclusion</h3>

<p> All the 3 plots are helpful in understanding how the quality of wines differ with chemical composition. 

  From the scatterplot matrix the following conclusions can be made:
  <ul> Volatile acidity has a negative correlation with sulphates and citric acid content. Also as seen from the groups formed, it can be noted that low quality wines are crowding towards higher volatile acidity levels. Two inferences can be made from here 1) Higher the volatile acidity levels, lower the quality. 2) The inverse relationship between volatile acidity and sulphate levels/ citric acid content suggests that higher the citric acid content or higher the sulphate levels higher the quality of wine. </ul>
  <ul> pH levels on its own does not help much in distinguishing the quality of wine. </ul>
  <ul> pH levels and citric acid levels have a negative correlation, with higher quality wines having lower pH levels and higher citric acid levels</ul>
  <ul>  Sulphates do not exhibit a strong relationship with any of the variables (except for volatile acidity) . However on an average, lower the sulphate levels , lower the quality levels as seen by the last row of the scatterplot matrix. </ul>

  The following patterns are seen from the parallel coordinate plot:
  <ul>As you brush along the alcohol coordinate top to bottom, there is an initial crowding of high quality wines and the quality level gradually changes  to low, showing higher the alcohol content, higher the quality of wine.</ul>
  <ul> Similarly, as seen from the scatterplot matrix, higher the sulphate levels, higher the quality.</ul>
  <ul> Also,lower the volatile acidity levels, higher the quality.</ul>
  <ul> Higher the citric acid levels, higher the quality</ul>
  <ul> Higher the fixed acidity, higher the quality</ul>
  <ul> In short, a high quality wine contains on an average higher alcohol content, higher sulphate levels, higher citric acid levels, higher fixed acidity levels, lower chloride levels and lower volatile acidity levels compared to the lower quality wines. </ul>

  The small multiple plot shows the average percentage of each of the chemical contents and is in accordance with the conclusions stated above.

<br></br>
<h10><a href="">Source code.</a></h10>

 Dataset courtesy: "P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. Modeling wine preferences by data mining from physicochemical properties. In Decision Support Systems, Elsevier, 47(4):547-553, 2009" 


</div>

